def number_of_terms(base_range, exp_range):
	"""Returns the number of terms generated by a ^ b for the given ranges of a and b, inclusive.

	number_of_terms(iter, iter) -> int
	"""
	from collections import defaultdict
	special_cases = dict()
	roots = defaultdict(set)
	num_terms = 0
	for base in range(base_range[0],base_range[1]+1):
		num_terms += number_of_new_terms(base, special_cases, roots, base_range, exp_range)
	#print("roots",roots)
	#print("special cases",special_cases)
	return num_terms
    
def number_of_new_terms(base, special_cases, roots, base_range, exponent_range):
	min_exp,max_exp = exponent_range
	min_base,max_base = base_range
	new_terms = max_exp - min_exp + 1
	if base not in special_cases:
		#print("found new num",base)
		exp_index = min_exp
		found_special_case = False
		while True:
			term = int(math.pow(base, exp_index))
			if term <= max_base:
				#print("found special case:",term)
				found_special_case = True
				special_cases[term] = (base,exp_index)
				exp_index += 1
			else:
				break
		if found_special_case:
			roots[base] = set([e for e in range(min_exp,max_exp+1)])
	else:

		root, root_exp = special_cases[base]
		#print("found",base,"with root",root)
		for e in range(min_exp, max_exp + 1):
			root_term = e*root_exp
			root_terms = roots[root]
			if root_term not in root_terms:
				#print(root_term,"not in",root_terms)
				#print("new term:",root,"to the",root_term)
				root_terms.add(root_term)
			else:
				#print("found",root,"to the",e,"already exists.")
				new_terms -= 1
	#print("Found",new_terms,"new terms.")
	return new_terms

ans = number_of_terms((2,100),(2,100))
